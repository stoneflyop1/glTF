// AUTOGENERATED FILE: easyjson marshaller/unmarshallers.

package glTF

import (
	json "encoding/json"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ = json.RawMessage{}
	_ = jlexer.Lexer{}
	_ = jwriter.Writer{}
)

func easyjson8d52c6a3DecodeGithubComSturfeeincGlTF(in *jlexer.Lexer, out *TechniqueStatesFunctions) {
	if in.IsNull() {
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeString()
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "blendColor":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.BlendColor = make([]float64, 0, 8)
			} else {
				out.BlendColor = nil
			}
			for !in.IsDelim(']') {
				var v1 float64
				v1 = float64(in.Float64())
				out.BlendColor = append(out.BlendColor, v1)
				in.WantComma()
			}
			in.Delim(']')
		case "blendEquationSeparate":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.BlendEquationSeparate = make([]int, 0, 8)
			} else {
				out.BlendEquationSeparate = nil
			}
			for !in.IsDelim(']') {
				var v2 int
				v2 = int(in.Int())
				out.BlendEquationSeparate = append(out.BlendEquationSeparate, v2)
				in.WantComma()
			}
			in.Delim(']')
		case "blendFuncSeparate":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.BlendFuncSeparate = make([]int, 0, 8)
			} else {
				out.BlendFuncSeparate = nil
			}
			for !in.IsDelim(']') {
				var v3 int
				v3 = int(in.Int())
				out.BlendFuncSeparate = append(out.BlendFuncSeparate, v3)
				in.WantComma()
			}
			in.Delim(']')
		case "depthMask":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.DepthMask = make([]bool, 0, 64)
			} else {
				out.DepthMask = nil
			}
			for !in.IsDelim(']') {
				var v4 bool
				v4 = bool(in.Bool())
				out.DepthMask = append(out.DepthMask, v4)
				in.WantComma()
			}
			in.Delim(']')
		case "frontFace":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.FrontFace = make([]int, 0, 8)
			} else {
				out.FrontFace = nil
			}
			for !in.IsDelim(']') {
				var v5 int
				v5 = int(in.Int())
				out.FrontFace = append(out.FrontFace, v5)
				in.WantComma()
			}
			in.Delim(']')
		case "lineWidth":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.LineWidth = make([]float64, 0, 8)
			} else {
				out.LineWidth = nil
			}
			for !in.IsDelim(']') {
				var v6 float64
				v6 = float64(in.Float64())
				out.LineWidth = append(out.LineWidth, v6)
				in.WantComma()
			}
			in.Delim(']')
		case "colorMask":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.ColorMask = make([]bool, 0, 64)
			} else {
				out.ColorMask = nil
			}
			for !in.IsDelim(']') {
				var v7 bool
				v7 = bool(in.Bool())
				out.ColorMask = append(out.ColorMask, v7)
				in.WantComma()
			}
			in.Delim(']')
		case "cullFace":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.CullFace = make([]int, 0, 8)
			} else {
				out.CullFace = nil
			}
			for !in.IsDelim(']') {
				var v8 int
				v8 = int(in.Int())
				out.CullFace = append(out.CullFace, v8)
				in.WantComma()
			}
			in.Delim(']')
		case "depthFunc":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.DepthFunc = make([]int, 0, 8)
			} else {
				out.DepthFunc = nil
			}
			for !in.IsDelim(']') {
				var v9 int
				v9 = int(in.Int())
				out.DepthFunc = append(out.DepthFunc, v9)
				in.WantComma()
			}
			in.Delim(']')
		case "depthRange":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.DepthRange = make([]float64, 0, 8)
			} else {
				out.DepthRange = nil
			}
			for !in.IsDelim(']') {
				var v10 float64
				v10 = float64(in.Float64())
				out.DepthRange = append(out.DepthRange, v10)
				in.WantComma()
			}
			in.Delim(']')
		case "polygonOffset":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.PolygonOffset = make([]float64, 0, 8)
			} else {
				out.PolygonOffset = nil
			}
			for !in.IsDelim(']') {
				var v11 float64
				v11 = float64(in.Float64())
				out.PolygonOffset = append(out.PolygonOffset, v11)
				in.WantComma()
			}
			in.Delim(']')
		case "scissor":
			in.Delim('[')
			if !in.IsDelim(']') {
				out.Scissor = make([]float64, 0, 8)
			} else {
				out.Scissor = nil
			}
			for !in.IsDelim(']') {
				var v12 float64
				v12 = float64(in.Float64())
				out.Scissor = append(out.Scissor, v12)
				in.WantComma()
			}
			in.Delim(']')
		case "extensions":
			out.Extensions = in.Interface()
		case "extras":
			out.Extras = in.Interface()
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
}
func easyjson8d52c6a3EncodeGithubComSturfeeincGlTF(out *jwriter.Writer, in TechniqueStatesFunctions) {
	out.RawByte('{')
	first := true
	_ = first
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"blendColor\":")
	out.RawByte('[')
	for v13, v14 := range in.BlendColor {
		if v13 > 0 {
			out.RawByte(',')
		}
		out.Float64(float64(v14))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"blendEquationSeparate\":")
	out.RawByte('[')
	for v15, v16 := range in.BlendEquationSeparate {
		if v15 > 0 {
			out.RawByte(',')
		}
		out.Int(int(v16))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"blendFuncSeparate\":")
	out.RawByte('[')
	for v17, v18 := range in.BlendFuncSeparate {
		if v17 > 0 {
			out.RawByte(',')
		}
		out.Int(int(v18))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"depthMask\":")
	out.RawByte('[')
	for v19, v20 := range in.DepthMask {
		if v19 > 0 {
			out.RawByte(',')
		}
		out.Bool(bool(v20))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"frontFace\":")
	out.RawByte('[')
	for v21, v22 := range in.FrontFace {
		if v21 > 0 {
			out.RawByte(',')
		}
		out.Int(int(v22))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"lineWidth\":")
	out.RawByte('[')
	for v23, v24 := range in.LineWidth {
		if v23 > 0 {
			out.RawByte(',')
		}
		out.Float64(float64(v24))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"colorMask\":")
	out.RawByte('[')
	for v25, v26 := range in.ColorMask {
		if v25 > 0 {
			out.RawByte(',')
		}
		out.Bool(bool(v26))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"cullFace\":")
	out.RawByte('[')
	for v27, v28 := range in.CullFace {
		if v27 > 0 {
			out.RawByte(',')
		}
		out.Int(int(v28))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"depthFunc\":")
	out.RawByte('[')
	for v29, v30 := range in.DepthFunc {
		if v29 > 0 {
			out.RawByte(',')
		}
		out.Int(int(v30))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"depthRange\":")
	out.RawByte('[')
	for v31, v32 := range in.DepthRange {
		if v31 > 0 {
			out.RawByte(',')
		}
		out.Float64(float64(v32))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"polygonOffset\":")
	out.RawByte('[')
	for v33, v34 := range in.PolygonOffset {
		if v33 > 0 {
			out.RawByte(',')
		}
		out.Float64(float64(v34))
	}
	out.RawByte(']')
	if !first {
		out.RawByte(',')
	}
	first = false
	out.RawString("\"scissor\":")
	out.RawByte('[')
	for v35, v36 := range in.Scissor {
		if v35 > 0 {
			out.RawByte(',')
		}
		out.Float64(float64(v36))
	}
	out.RawByte(']')
	if in.Extensions != nil {
		if !first {
			out.RawByte(',')
		}
		first = false
		out.RawString("\"extensions\":")
		out.Raw(json.Marshal(in.Extensions))
	}
	if in.Extras != nil {
		if !first {
			out.RawByte(',')
		}
		first = false
		out.RawString("\"extras\":")
		out.Raw(json.Marshal(in.Extras))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v TechniqueStatesFunctions) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjson8d52c6a3EncodeGithubComSturfeeincGlTF(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v TechniqueStatesFunctions) MarshalEasyJSON(w *jwriter.Writer) {
	easyjson8d52c6a3EncodeGithubComSturfeeincGlTF(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *TechniqueStatesFunctions) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjson8d52c6a3DecodeGithubComSturfeeincGlTF(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *TechniqueStatesFunctions) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjson8d52c6a3DecodeGithubComSturfeeincGlTF(l, v)
}
